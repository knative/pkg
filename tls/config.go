/*
Copyright 2026 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tls

import (
	cryptotls "crypto/tls"
	"fmt"
	"os"
	"strings"
)

// Environment variable name suffixes for TLS configuration.
// Use with a prefix to namespace them, e.g. "WEBHOOK_" + MinVersionEnvKey
// reads the WEBHOOK_TLS_MIN_VERSION variable.
const (
	MinVersionEnvKey       = "TLS_MIN_VERSION"
	MaxVersionEnvKey       = "TLS_MAX_VERSION"
	CipherSuitesEnvKey     = "TLS_CIPHER_SUITES"
	CurvePreferencesEnvKey = "TLS_CURVE_PREFERENCES"
)

// Config holds parsed TLS configuration values that can be used
// to build a *crypto/tls.Config.
type Config struct {
	MinVersion       uint16
	MaxVersion       uint16
	CipherSuites     []uint16
	CurvePreferences []cryptotls.CurveID
}

// NewConfigFromEnv reads TLS configuration from environment variables and
// returns a Config. The prefix is prepended to each standard env-var suffix;
// for example with prefix "WEBHOOK_" the function reads
// WEBHOOK_TLS_MIN_VERSION, WEBHOOK_TLS_MAX_VERSION, etc.
// Fields whose corresponding env var is unset are left at their zero value.
func NewConfigFromEnv(prefix string) (*Config, error) {
	var cfg Config

	if v := os.Getenv(prefix + MinVersionEnvKey); v != "" {
		ver, err := ParseVersion(v)
		if err != nil {
			return nil, fmt.Errorf("invalid %s%s %q: %w", prefix, MinVersionEnvKey, v, err)
		}
		cfg.MinVersion = ver
	}

	if v := os.Getenv(prefix + MaxVersionEnvKey); v != "" {
		ver, err := ParseVersion(v)
		if err != nil {
			return nil, fmt.Errorf("invalid %s%s %q: %w", prefix, MaxVersionEnvKey, v, err)
		}
		cfg.MaxVersion = ver
	}

	if v := os.Getenv(prefix + CipherSuitesEnvKey); v != "" {
		suites, err := ParseCipherSuites(v)
		if err != nil {
			return nil, fmt.Errorf("invalid %s%s: %w", prefix, CipherSuitesEnvKey, err)
		}
		cfg.CipherSuites = suites
	}

	if v := os.Getenv(prefix + CurvePreferencesEnvKey); v != "" {
		curves, err := ParseCurvePreferences(v)
		if err != nil {
			return nil, fmt.Errorf("invalid %s%s: %w", prefix, CurvePreferencesEnvKey, err)
		}
		cfg.CurvePreferences = curves
	}

	return &cfg, nil
}

// TLSConfig constructs a *crypto/tls.Config from the parsed configuration.
// The caller typically adds additional fields such as GetCertificate.
func (c *Config) TLSConfig() *cryptotls.Config {
	//nolint:gosec // Min version is caller-configurable; default is TLS 1.3.
	return &cryptotls.Config{
		MinVersion:       c.MinVersion,
		MaxVersion:       c.MaxVersion,
		CipherSuites:     c.CipherSuites,
		CurvePreferences: c.CurvePreferences,
	}
}

// ParseVersion converts a TLS version string to the corresponding
// crypto/tls constant. Accepted values are "1.2" and "1.3".
func ParseVersion(v string) (uint16, error) {
	switch v {
	case "1.2":
		return cryptotls.VersionTLS12, nil
	case "1.3":
		return cryptotls.VersionTLS13, nil
	default:
		return 0, fmt.Errorf("unsupported TLS version %q: must be %q or %q", v, "1.2", "1.3")
	}
}

// ParseCipherSuites parses a comma-separated list of TLS cipher-suite names
// (e.g. "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384")
// into a slice of cipher-suite IDs. Names must match those returned by
// crypto/tls.CipherSuiteName.
func ParseCipherSuites(s string) ([]uint16, error) {
	lookup := cipherSuiteLookup()
	parts := strings.Split(s, ",")
	suites := make([]uint16, 0, len(parts))

	for _, name := range parts {
		name = strings.TrimSpace(name)
		if name == "" {
			continue
		}
		id, ok := lookup[name]
		if !ok {
			return nil, fmt.Errorf("unknown cipher suite %q", name)
		}
		suites = append(suites, id)
	}

	return suites, nil
}

// ParseCurvePreferences parses a comma-separated list of elliptic-curve names
// (e.g. "X25519,CurveP256") into a slice of crypto/tls.CurveID values.
// Both Go constant names (CurveP256) and standard names (P-256) are accepted.
func ParseCurvePreferences(s string) ([]cryptotls.CurveID, error) {
	parts := strings.Split(s, ",")
	curves := make([]cryptotls.CurveID, 0, len(parts))

	for _, name := range parts {
		name = strings.TrimSpace(name)
		if name == "" {
			continue
		}
		id, ok := curvesByName[name]
		if !ok {
			return nil, fmt.Errorf("unknown curve %q", name)
		}
		curves = append(curves, id)
	}

	return curves, nil
}

func cipherSuiteLookup() map[string]uint16 {
	m := make(map[string]uint16)
	for _, cs := range cryptotls.CipherSuites() {
		m[cs.Name] = cs.ID
	}
	return m
}

var curvesByName = map[string]cryptotls.CurveID{
	"CurveP256":      cryptotls.CurveP256,
	"CurveP384":      cryptotls.CurveP384,
	"CurveP521":      cryptotls.CurveP521,
	"X25519":         cryptotls.X25519,
	"X25519MLKEM768": cryptotls.X25519MLKEM768,
	"P-256":          cryptotls.CurveP256,
	"P-384":          cryptotls.CurveP384,
	"P-521":          cryptotls.CurveP521,
}
